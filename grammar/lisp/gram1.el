; -*- mode:Emacs-Lisp; mode:outline-minor;   -*- 
; gram1.el  
; begun 07-16-02 by ejf
; All the code in itrans.el is assumed.
; The particular spelling of the symbols representing
; the phonetic elements (the 'tokens') must be consistent with 
; that in itrans.el

(defvar shortsimplevowel-set)
(defvar longsimplevowel-set)
(defvar simplevowel-set)
(defvar diphthong-set)
(defvar vowel-set)
(defvar K-set)
(defvar CH-set)
(defvar TT-set)
(defvar T-set)
(defvar P-set)
(defvar semivowel-set)
(defvar sibilant-set)
(defvar consonant-set)

(defvar guttural-set)
(defvar palatal-set)
(defvar cerebral-set)
(defvar dental-set)
(defvar labial-set)

(defvar hardnonaspirate-set)
(defvar hardaspirate-set)
(defvar softnonaspirate-set)
(defvar softaspirate-set)
(defvar nasal-set)
(defvar hard-set)
(defvar soft-set)

(defvar mute-set)
(defun init-sets-helper (s)
 (let (w w1 ans)
  (setq w (ITRANS-parse-words-1 s)) ; list of vectors, each of length 1
  (setq w1 (apply 'vconcat w)) ; 1 vector
  (setq ans (append w1 nil)) ; list with desired elements
  ans
 )
)
(defun init-sets ()
 (let (x)
  (setq shortsimplevowel-set (ITRANS-parse-words-3 "a i u R^i L^i"))
  (setq longsimplevowel-set  (ITRANS-parse-words-3 "aa ii uu R^I L^I"))
  (setq simplevowel-set (append shortsimplevowel-set longsimplevowel-set))
  (setq diphthong-set (ITRANS-parse-words-3 "e ai o au"))
  (setq vowel-set (append simplevowel-set diphthong-set))
  (setq K-set (ITRANS-parse-words-3 "k kh g gh ~N"))
  (setq CH-set (ITRANS-parse-words-3 "ch Ch  j jh ~n"))
  (setq TT-set (ITRANS-parse-words-3 "T Th D Dh N"))
  (setq T-set (ITRANS-parse-words-3 "t th d dh n"))
  (setq P-set (ITRANS-parse-words-3 "p ph b bh m"))
  (setq semivowel-set (ITRANS-parse-words-3 "y r l v h"))
  (setq sibilant-set (ITRANS-parse-words-3 "Sh  sh s H"))
  (let (temp)
   (setq temp (ITRANS-parse-words-3 "M")) ;anusvara
   (setq consonant-set (append 
    K-set CH-set TT-set T-set P-set semivowel-set sibilant-set temp))
  )
  (setq guttural-set (append K-set (ITRANS-parse-words-3 "h H")))
  (setq palatal-set (append CH-set (ITRANS-parse-words-3 "y sh")))
  (setq cerebral-set (append TT-set (ITRANS-parse-words-3 "r Sh")))
  (setq dental-set (append T-set (ITRANS-parse-words-3 "l s")))
  (setq labial-set (append P-set (ITRANS-parse-words-3 "v H")))

  (setq hardnonaspirate-set (ITRANS-parse-words-3 "k ch T t p"))
  (setq hardaspirate-set (ITRANS-parse-words-3 "kh Ch Th th ph"))
  (setq softnonaspirate-set (ITRANS-parse-words-3 "g j D d b"))
  (setq softaspirate-set (ITRANS-parse-words-3 "gh jh Dh dh bh"))
  (setq nasal-set (ITRANS-parse-words-3 "~N ~n N n m"))

  (setq hard-set (append hardnonaspirate-set hardaspirate-set sibilant-set))
  (setq soft-set
       (append softnonaspirate-set softaspirate-set nasal-set semivowel-set))

  (setq mute-set (append
       hardnonaspirate-set hardaspirate-set
       softnonaspirate-set softaspirate-set nasal-set))

  (setq Sangram-types '(dhaatu saarvadhaatuka))
  t
 )
)
(defun init-vs-helper (s1 p s2)
 (let (sym val i n)
  (setq sym (elt (ITRANS-parse-words-2 s1) 0))
  (setq val (ITRANS-parse-words-2 s2))
  (sanput sym p val)
;  (fol-msg (format "sym=%s, p=%s, val=%s\n" sym p val))
 )
)
(defun init-vowelstrength ()
 (init-vs-helper "a" 'guna "a")    (init-vs-helper "aa" 'guna "a") 
 (init-vs-helper "a" 'vrddhi "aa") (init-vs-helper "aa" 'vrddhi "aa") 

 (init-vs-helper "i" 'guna "e")    (init-vs-helper "ii" 'guna "e") 
 (init-vs-helper "i" 'vrddhi "ai") (init-vs-helper "ii" 'vrddhi "ai") 

 (init-vs-helper "u" 'guna "o")    (init-vs-helper "uu" 'guna "o") 
 (init-vs-helper "u" 'vrddhi "au") (init-vs-helper "uu" 'vrddhi "au") 

 (init-vs-helper "R^i" 'guna "a r")    (init-vs-helper "R^I" 'guna "a r") 
 (init-vs-helper "R^i" 'vrddhi "aa r") (init-vs-helper "R^I" 'vrddhi "aa r") 

 (init-vs-helper "L^i" 'guna "a l")   (init-vs-helper "L^I" 'guna "a l")
 (init-vs-helper "L^i" 'vrddhi "aa l") (init-vs-helper "L^I" 'vrddhi "aa l")
 ; this varies from antoine, but seems necessary in implementing
 ; algorithm for imperfect tense, namely verbs like 'uSh' (of Conj 1)
 
 (init-vs-helper "o" 'vrddhi "au")
 (init-vs-helper "e" 'vrddhi "ai")
 't
)
(defun init-semivowels ()
 (sanput 'i 'semivowel 'y)  (sanput 'ii 'semivowel 'y)
 (sanput 'u 'semivowel 'v)  (sanput 'uu 'semivowel 'v)
 (sanput 'Ri 'semivowel 'r)  (sanput 'RI 'semivowel 'r)
 (sanput 'Li 'semivowel 'l)  (sanput 'LI 'semivowel 'l)
)
(defun set-to-property (s p)
 (let (sym)
  (while s
   (setq sym (car s))
   (setq s (cdr s))
   (sanput sym p 't)
  )
 )
)
(defun init-properties ()
 (let (x)
  (set-to-property shortsimplevowel-set 'is-shortsimplevowel)
  (set-to-property longsimplevowel-set 'is-longsimplevowel)
  (set-to-property simplevowel-set 'is-simplevowel)
  (set-to-property diphthong-set 'is-diphthong)
  (set-to-property vowel-set 'is-vowel)
  (set-to-property K-set 'is-K)
  (set-to-property CH-set 'is-CH)
  (set-to-property TT-set 'is-TT)
  (set-to-property T-set 'is-T)
  (set-to-property P-set 'is-P)
  (set-to-property semivowel-set 'is-semivowel)
  (set-to-property sibilant-set 'is-sibilant)  
  (set-to-property consonant-set 'is-consonant)

  (set-to-property guttural-set 'is-guttural)
  (set-to-property palatal-set 'is-palatal)
  (set-to-property cerebral-set 'is-cerebral)
  (set-to-property dental-set 'is-dental)
  (set-to-property labial-set 'is-labial)
  (set-to-property hardnonaspirate-set 'is-hardnonaspirate)
  (set-to-property hardaspirate-set 'is-hardaspirate)
  (set-to-property softnonaspirate-set 'is-softnonaspirate)
  (set-to-property softaspirate-set 'is-softaspirate)
  (set-to-property nasal-set 'is-nasal)
  (set-to-property hard-set 'is-hard)
  (set-to-property soft-set 'is-soft)
  (set-to-property mute-set 'is-mute)
 )
)
(defun init-Sangram-helper (sym)
 (if (get sym 'Sangram) (put sym 'Sangram nil))
 (if (get sym 'XSangram) (put sym 'XSangram nil))
 't
)
(defun init-Sangram (&optional OBARRAY)
 (if (not OBARRAY) (setq OBARRAY obarray))
 (mapatoms 'init-Sangram-helper  OBARRAY)
 't
)
(defun count-Sangram ()
 (let (natom)
 (setq natom 0)
  (mapatoms 
   (lambda (x) (if (get x 'Sangram) (setq natom (1+ natom)))))
 natom)
)
(defun sangetall (sym)
 (get sym 'Sangram)
)
(defun sanget (sym prop)
 (let (Sangram)
  (setq Sangram (get sym 'Sangram))
  (plist-get Sangram prop)
 )
)
(defun plist-get2 (plist proplist)
 (let (prevans prop)
  (setq prevans plist)
  (while proplist
   (setq prop (car proplist))
   (setq proplist (cdr proplist))
   (setq prevans (plist-get prevans prop))
  )
  prevans
 )
)
(defun plist-AppendElt (plist prop newelt)
 (let (p val)
  (setq p plist)
  (setq val (plist-get p prop))
  (when (not (member newelt val))
   (setq val (append val (list newelt)))
   (setq p (plist-put p prop val))
  )
  p
 )
)
(defun sanget2 (sym proplist)
 (let (prevans prop)
  (setq prevans (get sym 'Sangram))
  (while proplist
   (setq prop (car proplist))
   (setq proplist (cdr proplist))
   (setq prevans (plist-get prevans prop))
  )
  prevans
 )
)
(defun sanput (sym prop val)
 (let (Sangram)
  (setq Sangram (get sym 'Sangram))
  (setq Sangram (plist-put Sangram prop val))
  (put sym 'Sangram Sangram)
 )
)
(defun sanput2 (sym proplist val)
; (setq sym 'as)
; (setq proplist [saarvadhaatuka other-info])
; (setq val '((chal 1 P)))
 (let (xgram prop  propvec plists plist nprop iprop nprop1)
  (setq propvec (vconcat proplist))
  (setq nprop (length propvec))
  (setq nprop1 (1+ nprop))
  (setq plists (make-vector nprop1 nil))
  (setq xgram (get sym 'Sangram))
;  (fol-msg (format "xgram(before): %s\n" xgram))
  (setq iprop 0)
  (aset plists iprop xgram)
  (while (< iprop nprop)
   (setq plist (elt plists iprop))
   (setq prop (elt propvec iprop))
   (aset plists (1+ iprop) (plist-get plist prop))
   (setq iprop (1+ iprop))
  )
; (fol-msg (format "before: %s\n" plists))

  (aset plists nprop val)
  (setq iprop nprop)
  (while (< 0 iprop)
   (setq iprop (1- iprop))
   (setq prop (elt propvec iprop))
   (setq plist (elt plists iprop))
   (setq plist (plist-put plist prop (elt plists (1+ iprop))))
   (aset plists iprop plist)
  )
; (fol-msg (format "after: %s\n" plists))

  (setq xgram (elt plists 0))
;  (fol-msg (format "xgram(after ): %s\n" xgram))
  (put sym 'Sangram xgram)
 )
)

(defun sanAppendElt (sym prop newelt)
 (let (Sangram val)
  (setq Sangram (get sym 'Sangram))
  (setq val (plist-get Sangram prop))
  (when (not (member newelt val))
   (setq val (append val (list newelt)))
   (setq Sangram (plist-put Sangram prop val))
   (put sym 'Sangram Sangram)
  )
 )
)
(defun sanAppendElt2 (sym proplist val)
; (setq sym 'as)
; (setq proplist [saarvadhaatuka other-info])
; (setq val '((chal 1 P)))
;  (when (equal sym 's)
;   (fol-msg (format "sanAppendElt2: %s %s %s\n" sym proplist val))
;  )
 (let (xgram prop  propvec plists plist nprop iprop nprop1)
  (setq propvec (vconcat proplist))
  (setq nprop (length propvec))
  (setq nprop1 (1+ nprop))
  (setq plists (make-vector nprop1 nil))
  (setq xgram (get sym 'Sangram))
  (setq iprop 0)
  (aset plists iprop xgram)
  (while (< iprop nprop)
   (setq plist (elt plists iprop))
   (setq prop (elt propvec iprop))
   (aset plists (1+ iprop) (plist-get plist prop))
   (setq iprop (1+ iprop))
  )
  (setq plist (elt plists nprop))
  (setq plist (append-if-new plist val))
  (aset plists nprop plist)
  (setq iprop nprop)
  (while (< 0 iprop)
   (setq iprop (1- iprop))
   (setq prop (elt propvec iprop))
   (setq plist (elt plists iprop))
   (setq plist (plist-put plist prop (elt plists (1+ iprop))))
   (aset plists iprop plist)
  )
  (setq xgram (elt plists 0))
  (put sym 'Sangram xgram)
 )
)
(defun shortsimplevowel-P (tok)
 (sanget tok 'is-shortsimplevowel)
)
(defun disjoint-P (list1 list2)
 "returns t only when list1 and list2 are lists with no common elements"
 (cond
  ((not (listp list1)) nil)
  ((not (listp list2)) nil)
  ((not (isect-lists list1 list2)))
 )
)
(defun isect-lists (list1 list2)
 "returns this list of elements common to two lists.
  If list1 has repeated elements, these will be repeated in answer"
 (apply 'append
	(mapcar (lambda (x1) (if (member x1 list2) (list x1))) list1))
)
(defun append-if-new (ans thisans)
 (if (not (member thisans ans))
  (append ans (list thisans))
  ans
 )
)

(defun longsimplevowel-P (tok)
 (sanget tok 'is-longsimplevowel)
)
(defun simplevowel-P (tok)
 (sanget tok 'is-simplevowel)
)
(defun diphthong-P (tok)
 (sanget tok 'is-diphthong)
)
(defun vowel-P (tok)
 (sanget tok 'is-vowel)
)
(defun K-P (tok)
 (sanget tok 'is-K)
)
(defun CH-P (tok)
 (sanget tok 'is-CH)
)
(defun TT-P (tok)
 (sanget tok 'is-TT)
)
(defun T-P (tok)
 (sanget tok 'is-T)
)
(defun P-P (tok)
 (sanget tok 'is-P)
)
(defun semivowel-P (tok)
 (sanget tok 'is-semivowel)
)
(defun sibilant-P (tok)
 (sanget tok 'is-sibilant)
)
(defun consonant-P (tok)
 (sanget tok 'is-consonant)
)
(defun guttural-P (tok)
 (sanget tok 'is-guttural)
)
(defun palatal-P (tok)
 (sanget tok 'is-palatal)
)
(defun cerebral-P (tok)
 (sanget tok 'is-cerebral)
)
(defun dental-P (tok)
 (sanget tok 'is-dental)
)
(defun labial-P (tok)
 (sanget tok 'is-labial)
)
(defun hardnonaspirate-P (tok)
 (sanget tok 'is-hardnonaspirate)
)
(defun hardaspirate-P (tok)
 (sanget tok 'is-hardaspirate)
)
(defun softnonaspirate-P (tok)
 (sanget tok 'is-softnonaspirate)
)
(defun softaspirate-P (tok)
 (sanget tok 'is-softaspirate)
)
(defun nasal-P (tok)
 (sanget tok 'is-nasal)
)
(defun hard-P (tok)
 (sanget tok 'is-hard)
)
(defun soft-P (tok)
 (sanget tok 'is-soft)
)
(defun mute-P (tok)
 (sanget tok 'is-mute)
)


; (defun guna (tok)
;  (if (simplevowel-P tok) (sanget tok 'guna) (vector tok))
; )
; (defun vrddhi (tok)
;  (if (simplevowel-P tok) (sanget tok 'vrddhi) (vector tok))
; )
(defun shortvowel-P (v)
 (shortsimplevowel-P v)
)
(defun longvowel-P (v)
 (longsimplevowel-P v)
)
(defun count-XSangram ()
 (let (natom)
 (setq natom 0)
  (mapatoms 
   (lambda (x) (if (get x 'XSangram) (setq natom (1+ natom)))))
 natom)
)
(defun Xsangetall (sym)
 (get sym 'XSangram)
)
(defun Xsanget (sym prop)
 (let (XSangram)
  (setq XSangram (get sym 'XSangram))
  (plist-get XSangram prop)
 )
)

(defun Xsanget2 (sym proplist)
 (let (prevans prop)
  (setq prevans (get sym 'XSangram))
  (while proplist
   (setq prop (car proplist))
   (setq proplist (cdr proplist))
   (setq prevans (plist-get prevans prop))
  )
  prevans
 )
)
(defun Xsanput (sym prop val)
 (let (XSangram)
  (setq XSangram (get sym 'XSangram))
  (setq XSangram (plist-put XSangram prop val))
  (put sym 'XSangram XSangram)
 )
)
(defun Xsanput2 (sym proplist val)
 (let (xgram prop  propvec plists plist nprop iprop nprop1)
  (setq propvec (vconcat proplist))
  (setq nprop (length propvec))
  (setq nprop1 (1+ nprop))
  (setq plists (make-vector nprop1 nil))
  (setq xgram (get sym 'XSangram))
  (setq iprop 0)
  (aset plists iprop xgram)
  (while (< iprop nprop)
   (setq plist (elt plists iprop))
   (setq prop (elt propvec iprop))
   (aset plists (1+ iprop) (plist-get plist prop))
   (setq iprop (1+ iprop))
  )
  (aset plists nprop val)
  (setq iprop nprop)
  (while (< 0 iprop)
   (setq iprop (1- iprop))
   (setq prop (elt propvec iprop))
   (setq plist (elt plists iprop))
   (setq plist (plist-put plist prop (elt plists (1+ iprop))))
   (aset plists iprop plist)
  )

  (setq xgram (elt plists 0))
  (put sym 'XSangram xgram)
 )
)

(defun XsanAppendElt (sym prop newelt)
 (let (XSangram val)
  (setq XSangram (get sym 'XSangram))
  (setq val (plist-get XSangram prop))
  (when (not (member newelt val))
   (setq val (append val (list newelt)))
   (setq XSangram (plist-put XSangram prop val))
   (put sym 'XSangram XSangram)
  )
 )
)
(defun XsanAppendElt2 (sym proplist val)
 (let (xgram prop  propvec plists plist nprop iprop nprop1)
  (setq propvec (vconcat proplist))
  (setq nprop (length propvec))
  (setq nprop1 (1+ nprop))
  (setq plists (make-vector nprop1 nil))
  (setq xgram (get sym 'XSangram))
  (setq iprop 0)
  (aset plists iprop xgram)
  (while (< iprop nprop)
   (setq plist (elt plists iprop))
   (setq prop (elt propvec iprop))
   (aset plists (1+ iprop) (plist-get plist prop))
   (setq iprop (1+ iprop))
  )
  (setq plist (elt plists nprop))
  (setq plist (append-if-new plist val))
  (aset plists nprop plist)
  (setq iprop nprop)
  (while (< 0 iprop)
   (setq iprop (1- iprop))
   (setq prop (elt propvec iprop))
   (setq plist (elt plists iprop))
   (setq plist (plist-put plist prop (elt plists (1+ iprop))))
   (aset plists iprop plist)
  )
  (setq xgram (elt plists 0))
  (put sym 'XSangram xgram)
 )
)

(defun listify (x)
 (if (not (listp x)) (list x) x)
)
(defun prog-comments (tab &optional dir)
 (let (file buf expr more)
  (if (not dir) (setq dir "lisp"))
  (setq file (sangram-filename tab dir))
  (setq buf (find-file-noselect file 't)) ; 't suppresses warning
  (with-current-buffer buf
   (goto-char 1)
   (setq case-fold-search nil)
   (setq more t)
   (while more
;   (forward-list)
    (setq expr (fol-read (current-buffer)))
    (when (not expr) (setq more nil))
    (when expr
     (let (fname args comment)
      (fol-msg (format "prog: %s\n" (elt expr 1)))
      (fol-msg (format "args: %s\n" (elt expr 2)))
      (setq comment (elt expr 3))
      (if (not (stringp comment)) (setq comment nil))
      (fol-msg (format "comm: %s\n" comment))
      
;     (goto-char (point-max))
     )
    )
   )
  )
  (kill-buffer buf)
  t
 )
)
