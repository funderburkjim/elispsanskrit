; start0.el  10-10-2015
; Things from start.el
; 10/10/2015 added 'current-line' function, from old/mw.el



(defun fol-msg (&rest s)
 "insert a message at the current point of the buffer
  whose name is given by fol-msg-buffer, initially *scratch*"
 (with-current-buffer fol-msg-buffer
   (apply 'insert s)
 )
)
(defun sangram-filename (arg  gramdir)
 (let (ans fname dir0 dir1)
  (setq dir1 (concat "grammar/" gramdir "/"))
  (setq dir0 (fol-filename dir1))
  (setq ans (symbolp arg))
  (setq fname (cond
   ((symbolp arg) (symbol-name arg))
   ((stringp arg) arg)
   (t nil)
  ))
  (setq ans (if fname
		(expand-file-name fname dir0)))
  (when (not ans)
   (fol-msg (format "san-tables-filename: value of default directory is %s\n"
		    dir0))
  )
  ans
 ) 
)
(defun sangram-buffer (arg gramdir)
 (let (file buf)
  (setq file (sangram-filename arg gramdir))
  (setq buf (find-file-noselect file 't)) ; 't suppresses warning
  buf
 )
)
(defun san-validation-filename (arg)
 (sangram-filename arg "validation")
)
(defun fol-filename (arg)
 "assume arg is a symbol or string representing a filename in an
  fol command like FileQ. Construct its full path name.
  return nil if some problem."
 (let (ans fname dir)
  (setq ans (symbolp arg))
  (setq fname (cond
   ((symbolp arg) (symbol-name arg))
   ((stringp arg) arg)
   (t nil)
  ))
  (setq dir (expand-file-name fol-default-directory))
  (setq ans (if fname
		(expand-file-name fname fol-default-directory)))
  (when (not ans)
   (fol-msg (format "value of fol-default-directory is %s\n"
		    fol-default-directory))
  )
  ans
 )
)
(defun fol-ob-init ()
 "initializes fol-ob,an obarray which contains all symbols
  generated by fol-read as well as 'internal' symbols for fol"
  (setq fol-ob (make-vector 511 0))
)
(defun fol-read (s)
  "'read' the argument from current buffer, interning variables into fol-ob
   global obarray-save keeps the system obarray. Returns nil if
   a problem."
; 11-27-00 this approach is dangerous to use.
; if there is an error in read (e.g., end of file)
; then almost none of the usual lisp functions will 
; work, e.g., one cannot (setq obarray obarray-save)
  (let (x y obarray-save) 
   (setq obarray-save obarray)
   (setq obarray fol-ob)
   (setq fol-read-err nil)
   (condition-case nil
    (setq x (read s));   (setq obarray obarray-save)
    (error
     (progn
       (setq x nil)
       (let (xx)
	(with-current-buffer s (setq xx (point)))
        (fol-msg (format "fol-read error: %s %s\n" s xx))
	(setq fol-read-err 't)
       )
      )
     )
    )
    (setq obarray obarray-save)
    x
  )
)
(defun my-load-library (sin &optional skip-flag)
 (let (s)
  (setq s (fol-filename sin))
  ;(message (format "my-load-library begin: %s" s))
  (if (not skip-flag)
   (progn
    (load-library s)
   ;(message (format "finished %s" s))
   ;(fol-msg (format "my-load-library done : %s \n" s))
   )
   (progn
    (fol-msg (format "%s:   LIBRARY not loaded (skip-flag)\n" s))
    (message (format "%s:   LIBRARY not loaded (skip-flag)\n" s))
   ) 
  )  
 )
)

(defun current-line ()
 "Assumes there is a current EMACS buffer.
  Returns the current line of this buffer as a string.
 "
 (let (p1 p0 p2 s)
  (setq p0 (point))
  (beginning-of-line)
  (setq p1 (point))
  (end-of-line)
  (setq p2 (point))
  (setq s (buffer-substring p1 p2))
  (goto-char p0)
  s
 )
)
