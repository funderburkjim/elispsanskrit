; -*- mode:Emacs-Lisp; mode:outline-minor;   -*- 
; vt01.el
; begun 07-20-02 by ejf
; Code in the following may be used:
;   itrans.el, gram1.el, sandhi.el, gram2.el
; This code is used to work with the vt01 verb table data
; from Antoine, volume 2.
; (vt01-act1 (vt01-read)) shows all data 
(defun vt01-read ()
 (let (fn filename buf ans x)
  (setq fn "antoine2/verbs/vt01.txt")
  (setq filename (fol-filename fn))
  (setq ans nil)

  (with-temp-buffer
   (insert-file-contents filename)
   (goto-char 1)
   (while (search-forward ".h" nil t)
     (replace-match "" nil t))
   (goto-char 1)
   (while (search-forward "R^" nil t)
     (replace-match "R" nil t))
   (goto-char 1)
   (while (search-forward "L^" nil t)
     (replace-match "L" nil t))
   (goto-char 1)
   (while (search-forward "," nil t)
     (replace-match " , " nil t))
   (goto-char 1)
   (while (search-forward "<" nil t)
     (replace-match "; <" nil t))
   (goto-char 1)
   (while (search-forward "GY" nil t)
     (replace-match "j~n" t t)) ; first 't' = FIXEDCASE
   (goto-char 1)

   (while (< (point) (point-max))
    ;(fol-msg (format "point: %s\n" (point)))
    (setq x (read (current-buffer)))
    (setq ans (append ans (list x)))
    (forward-line)
   )
  )
  ans
 )
)

(defun vt01-act1 (vtab)
; vtab is the output of vt01-read
 (let (ans xdat vfmt vrec x xrec y comma j f)
  (setq comma ', )
  (setq xdat nil)
  (setq vfmt (car vtab))
  (setq vtab (cdr vtab))
  (while vtab
   (setq vrec (car vtab))
   (setq vtab (cdr vtab))
   (setq xrec nil)
   (setq j 0)
   (setq f nil)
   (while vrec
    (setq x nil)
    (setq f (car vrec))
    ;(fol-msg (format " field %s = %s\n" j f))
    (while (and vrec (not (eq f comma)))
     (setq x (append x (list f)))
     (setq vrec (cdr vrec))
     (setq j (1+ j))
     (setq f (car vrec))
    ; (fol-msg (format " field %s = %s\n" j f))
    )
    (setq vrec (cdr vrec))
    (setq j (1+ j))
   ; (fol-msg (format "output field: %s\n" x))
    (setq xrec (append xrec (list x)))
   )
   (when (eq f comma) ; for blank last field
    (setq x nil)
   ; (fol-msg (format "output field: %s\n" x))
    (setq xrec (append xrec (list x)))
   )
   (setq xdat (append xdat (list xrec)))
  )
  xdat
 )
)
(defun vt01-check ()
 (let (n m m1 ml mh i x y vtab vtab1 nerr)
  (setq vtab (vt01-read))
  ; the record descriptor
  (setq vtab1 (vt01-act1 (list nil (nth 0 vtab))))
  (setq x vtab1)
  (setq m (length (nth 0 x)))
  (fol-msg (format "records in vt01.txt have %s fields:\n%s\n" m (nth 0 x)))
  ; the real records
  (setq vtab1 (vt01-act1 vtab))
  (setq x vtab1)
  (setq n (length x))
  (fol-msg (format "There are %s records\n" n))
  (setq nerr 0)
  (setq i 0)
  (while (< i n)
   (setq y (car x))
   (setq x (cdr x))
   (setq m1 (length y))
   (when (not (= m1 m)) 
     (fol-msg (format "rec %s has length %s, not %s\n rec=%s\n" i m1 m y))
     (setq nerr (1+ nerr))
   )
   (setq i (1+ i))
  )
  (if (= nerr 0)
   (fol-msg (format "All records have %s fields.\n" m))
   (fol-msg (format "Error:  %s records fail to have exactly %s fields.\n"
             nerr m))
  )
  (= nerr 0)
 )
)
(defun vt01-propnames ()
 (let (x y z)
  (setq x 
   '((root) (conj) (meaning) (pres-3s-P) (pres-3s-A) (pres-pass-3s)
   (perf-3s) (fut-3s) (caus-pres-3s)
   (desid-3s) (pot-pass-part) (perf-pass-part)
   (ind-past-part) (ind-past-part-pfx) (inf)))
  (setq y (mapcar 'car x))
  (setq z (vconcat y)) ; makes an array
  z
 )
)
(defun vt01-putrec (sym parr rec)
 (let (vrec i x n)
  (setq vrec (vconcat rec)) ; array slightly faster
  (setq n (length rec))
  (setq i 0)
  (while (< i n)
   (put sym (elt parr i) (elt rec i))
   (setq i (1+ i))
  )
 )
)
(defun vt01-act2 ()
 (let (vtab vtab1 rec prec sym)
  (setq vtab (vt01-read))
  (setq vtab1 (vt01-act1 vtab))
  (setq prec (vt01-propnames))
  (setq sym 'vt01rec)
  (while vtab1
   (vt01-putrec sym prec (car vtab1))
   (setq vtab1 (cdr vtab1))
   (let (dhaatu conj pada forms engdef a-form p-form)
    (setq dhaatu (car (get sym 'root)))
    (setq conj (car (get sym 'conj)))
    ; (mapconcat FUNCTION SEQUENCE SEPARATOR)
    (setq engdef (get sym 'meaning))
    (if (eq (elt engdef 0) 'to) (setq engdef (cdr engdef)))
    (setq engdef (mapconcat 'symbol-name engdef " "))
    (setq p-form (get sym 'pres-3s-P))
    (setq a-form (get sym 'pres-3s-A))
    ; set pada and forms
    (cond
     ((and p-form a-form) 
      (setq pada 'U)
      (setq forms (append p-form a-form))
      (setq forms (mapconcat 'symbol-name forms " "))
     )
     (p-form
      (setq pada 'P)
      (setq forms p-form)
      (setq forms (mapconcat 'symbol-name forms " "))
     )
     (a-form
      (setq pada 'A)
      (setq forms a-form)
      (setq forms (mapconcat 'symbol-name forms " "))
      )
    )
    (fol-msg (format "%s : %s %s :  : %s ; %s : Antoine\n"
	      dhaatu conj pada engdef forms))
   )
  )
 )
)

(defun vt01-act3 ()
 (let (vtab vtab1 rec prec sym)
  (setq vtab (vt01-read))
  (setq vtab1 (vt01-act1 vtab))
  (setq prec (vt01-propnames))
  (setq sym 'vt01rec)
  (while vtab1
   (vt01-putrec sym prec (car vtab1))
   (setq vtab1 (cdr vtab1))
   (let (dhaatulist dhaatu conj pada forms engdef a-form p-form)
    (setq dhaatulist (get sym 'root))
;     (if (not (= (length dhaatulist) 1))
;      (fol-msg (format "warning: dhaatu several words: %s\n" dhaatulist))
;     )
    (setq dhaatu (car dhaatulist))
    (setq conj (car (get sym 'conj)))
    ; (mapconcat FUNCTION SEQUENCE SEPARATOR)
    (setq engdef (get sym 'meaning))
    (if (eq (elt engdef 0) 'to) (setq engdef (cdr engdef)))
    (setq engdef (mapconcat 'symbol-name engdef " "))
    (setq p-form (get sym 'pres-3s-P))
    (setq a-form (get sym 'pres-3s-A))
    ; set pada and forms
    (cond
     ((and p-form a-form) 
      (setq pada 'U)
      (setq forms (append p-form a-form))
      (setq forms (mapconcat 'symbol-name forms " "))
     )
     (p-form
      (setq pada 'P)
      (setq forms p-form)
      (setq forms (mapconcat 'symbol-name forms " "))
     )
     (a-form
      (setq pada 'A)
      (setq forms a-form)
      (setq forms (mapconcat 'symbol-name forms " "))
      )
    )
    (fol-msg (format "%s : %s : %s : Antoine\n"
         dhaatu conj engdef ))
   )
  )
 )
)

(defun vt01-act4 (prop)
; used to extract perfect passive participle 
 (let (vtab vtab1 rec prec sym)
  
  (setq vtab (vt01-read))
  (setq vtab1 (vt01-act1 vtab))
  (setq prec (vt01-propnames))
  (setq sym 'vt01rec)
  (while vtab1
   (vt01-putrec sym prec (car vtab1))
   (setq vtab1 (cdr vtab1))
   (let (dhaatulist dhaatu val valp)
    (setq dhaatulist (get sym 'root))
;     (if (not (= (length dhaatulist) 1))
;      (fol-msg (format "warning: dhaatu several words: %s\n" dhaatulist))
;     )
    (setq dhaatu (car dhaatulist))
    (setq val (get sym prop))
    (cond
     ((not val)
      (fol-msg (format " ERR %s\n" dhaatu))
      )
     (t
      (setq valp (sym-with-space (vconcat val)))
      (fol-msg (format "%s : %s\n" dhaatu valp))
     )
    )
   )
  )
 )
)
